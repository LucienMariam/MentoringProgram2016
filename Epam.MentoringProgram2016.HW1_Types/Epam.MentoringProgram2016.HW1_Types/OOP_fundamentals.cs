//                                                        ACCESS MODIFIERS
/*
 
public: члены, помеченные как public доступны везде как внутри своего namespace, так и при обращении к ним снаружи из других namespace-ов,
также доступны при обращении к ним из других сборок. На члены с доступом типа public не накладываются никаких ограничений доступа.

protected: CLR читает этот модификатор как Family. Члены, помеченные как protected доступны внутри своего типа, во всех вложенных в этот тип классах,
а также во всех унаследованных от него типах. Обратиться к protected члену можно и из других сборок.

internal: CLR читает этот модификатор как Assembly. Члены, помеченные как internal имеют уровень доступа как public, но только внутри своей сборки.

protected internal: CLR читает этот модификатор как Family or Assembly. Члены, помеченные как protected internal доступны внутри своего типа,
во всех вложенных в этот тип классах, а также во всех унаследованных от него типах, но только в пределах своей сборки. Обратиться к protected члену из других сборок нельзя.

private: Члены, помеченные как private доступны только внутри своего типа, а также во всех вложенных в этот тип классах.

Если модификатор доступа не указан, то компилятор по умолчанию выберет самый закрытый тип доступа.

*/

//                                             STATIC CLASSES VS INSTANCE CLASSES, METHODS
/*

Статические классы лишены возможности иметь свои экземпляры. Соответственно есть ограничение,
что статические классы могут содержать только статические поля, методы, свойства и события, привязанные исключительно к данному static типу.
Есть и другие ограничения, наложенные на статический класс. Например, static class не может реализовывать никаких интерфейсов. Попытка вызовет ошибку компиляции.
Также static класс нельзя использовать в тех ситуациях, когда его использование подразумевает наличие экземпляра класса.
Например, нельзя такой класс использовать при его передачи в функцию в качестве аргумента. Это так же будет ошибкой компиляции.

Обращение к полям и методам статического типа происходит быстрее, чем у обычного класса, за счёт того, что нет необходимости предварительно создавать объект,
обращение идёт напрямую к типу.
Минусом же является то, что статические классы затруднительно тестировать по той же самой причине - они не имеют своих объектов.
Следовательно, в юнит тестах не получится замокать статик класс.

Если есть хоть малейшая необходимость рассматривать бизнес сущность как объект или нам возможно понадобится создавать несколько и более объектов по единому образцу,
то безусловно нужно использовать обычный instance класс.
Т.к. обычный класс не облагается такими ограничениями, какими обладает статический, то его использование является достаточно гибким в пределах разрабатываемой архитектуры. 

*/

//                                                  INTERFACE AND ABSTRACT CLASS
/*

Интерфейс определяет своего рода контракт, согласно которому все наследники обязуются дать реализацию функционала интерфейса.
Интерфейсы удобно накладывать на логические сущности разрабатываемой системы, которые имеют конечные use case-ы эксплуатации системы со стороны пользователя.
Также интерфейсы удобно использовать для унифицированного поведения различных логических сущностей внутри разрабатываемой системы.
И конечно же интерфейсы позволяют грамотно структурировать функциональность кода, например, используя паттерны проектирования.

Интерфейс может содержать только публичные абстрактные методы, ивенты, индексаторы и свойства. 

Абстрактный же класс полезен в том случае, когда уместно вынести определённую default реализацию в одну сущность для повторного использования в классах наследниках. Ведь,
в отличии от интерфейса, абстрактный класс может содержать не только абстрактные методы, но и любую дэфолтную реализацию, которую будут использовать классы наследники.
Нельзя создать экземпляр абстрактного класса. Его конструктор не может быть public.

 */

//                                                           GET TYPE
/*

Данный метод принадлежит типу System.Object, а значит и всем остальным типам тоже. Get Type нельзя переопределить, он не является виртуальным методом.
Сделано так для того, чтобы при анализе метаданных типа для CLR всегда было однозначно каким типом является объект.
Соответственно этот метод можно вызвать на любом объекте любого типа.
Смысл метода в том, что он возвращает объект производный от Type, который указывает на тип объекта, вызвавшего этот метод.
*/

//                                                 MULTIPLE VS SINGLE INHERITANCE
/*

Множественное наследование от классов не поддерживается средой CLR в C#. CLR позволяет реализовывать только множественное наследовние от интерфейсов.
Сделано было так разработчиками языка потому, что у различных языков существует своё представление о том, как должно работать множественное наследование.
(одни языки, поддерживаемые CLR, обладают множественным наследованием, а другие нет)
Т.к. .NET по своей сути допускает использование мультиязычного кода, то разработчики решили, что если они разрешат множественное наследование в C#,
то "овчинка не будет стоить выделки", и для упрощения языковой реализации решили специфицировать поведение, запретив множественное наследование от классов.

*/

//                                                        POLYMORPHISM
/*

С одной стороны это способность типов, находящихся в иерархии наследования, предоставлять разные реализации абстрактных функций, а также расширять уже имеющиеся реализации,
с другой стороны это возможность компилятора воспринимать производные типы в качестве базового при передачи аргументов в функцию и при использовании дженерик контейнеров.
Отличным примером полиморфизма служит ситуация с наследованием от интерфейса: все классы-наследники обязаны дать свою собственную реализацию абстрактным методам интерфейса.
Так же существует и ad hoc полиморфизм, смысл которого заключается в перегрузке методов типа.
На практике же перегруженные функции имеют разные реализации и отличаются входными параметрами.

 */